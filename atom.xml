<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://merpyzf.github.io</id>
    <title>It&apos;s my life</title>
    <updated>2020-03-21T05:48:31.358Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://merpyzf.github.io"/>
    <link rel="self" href="https://merpyzf.github.io/atom.xml"/>
    <subtitle>真正的光芒，需要一点点时间</subtitle>
    <logo>https://merpyzf.github.io/images/avatar.png</logo>
    <icon>https://merpyzf.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, It&apos;s my life</rights>
    <entry>
        <title type="html"><![CDATA[关于Cordova&IonicNative插件开发遇到的一些坑]]></title>
        <id>https://merpyzf.github.io/post/guan-yu-cordovaandionicnative-cha-jian-kai-fa-yu-dao-de-yi-xie-keng/</id>
        <link href="https://merpyzf.github.io/post/guan-yu-cordovaandionicnative-cha-jian-kai-fa-yu-dao-de-yi-xie-keng/">
        </link>
        <updated>2020-03-16T03:32:28.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-在ionic-native下编译生成的类型声明包中的js文件内会对cordova进行重复引用">1. 在ionic-native下编译生成的类型声明包中的js文件内会对cordova进行重复引用：</h3>
<figure data-type="image" tabindex="1"><img src="https://merpyzf.github.io/post-images/1584329762977.png" alt="" loading="lazy"></figure>
<p>解决方法：删除多余引入的cordova模块</p>
<h3 id="2-在类型声明文件indexdts中为调用native层功能的方法的返回结果指定为observable不生效">2. 在类型声明文件index.d.ts中为调用Native层功能的方法的返回结果指定为Observable不生效：</h3>
<p>index.d.ts文件内部方法声明：</p>
<pre><code>  /**
   * 开启对条码扫描结果的接收
   */
  @cordova()
  openScanReceiver(): Observable&lt;any&gt; {
    return;
  }
</code></pre>
<p>解决方法：<br>
<img src="https://merpyzf.github.io/post-images/1584330103891.png" alt="" loading="lazy"><br>
给以上截图中的两个index.js补充 <code>{&quot;observable&quot;: true }</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[adb error: more than one device]]></title>
        <id>https://merpyzf.github.io/post/adb-error-more-than-one-device/</id>
        <link href="https://merpyzf.github.io/post/adb-error-more-than-one-device/">
        </link>
        <updated>2020-03-16T02:58:24.000Z</updated>
        <content type="html"><![CDATA[<p>You can run every command of adb by selecting the device by deviceID. run command to get Device Id:</p>
<pre><code>adb devices
</code></pre>
<p>you will get the list of all available devices something like this:</p>
<pre><code>&lt;device ID&gt; device
emulator-5554 offline
</code></pre>
<p>the copy the device id run commad like this:</p>
<pre><code>adb -s &lt;device ID&gt; &lt;your command&gt;
</code></pre>
<p>example:</p>
<pre><code>adb -s &lt;device ID&gt; tcpip 5555
</code></pre>
<p>OR</p>
<pre><code>adb -s &lt;device ID&gt; forward tcp:59900 tcp:59900
</code></pre>
<p>this will not get the error like &quot;more than one device/emulator&quot;</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[移动端开发技术公司内部分享活动]]></title>
        <id>https://merpyzf.github.io/post/yi-dong-duan-kai-fa-ji-zhu-gong-si-nei-bu-fen-xiang-huo-dong/</id>
        <link href="https://merpyzf.github.io/post/yi-dong-duan-kai-fa-ji-zhu-gong-si-nei-bu-fen-xiang-huo-dong/">
        </link>
        <updated>2020-03-16T02:12:59.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-第三方和自定义cordova插件的使用方法">一、第三方和自定义Cordova插件的使用方法</h1>
<h2 id="为什么需要使用插件">为什么需要使用插件？</h2>
<p>我们基于Ionic开发的项目最终是需要通过Cordova打包才可以发布到应用市场。其本质是一个运行在移动端浏览器上的 Web App，它不具备访问设备底层的能力。当开发的功能涉及到对设备底层功能的调用时，比如拍照、保存文件到本地存储这些涉及原生调用功能时候就需要借助Cordova插件来搭建一个桥梁，供Web App与能够调用设备底层功能的原生代码进行通信。</p>
<h2 id="ionic-native-和-cordova-plugin-之间的关系">Ionic Native 和 Cordova Plugin 之间的关系？</h2>
<p>Ionic Native是一个为Cordova打造的一款TypeScript打包器。它的作用在于可以在你ionic移动端应用上添加任何你想要的原生app的功能。Ionic Native调用设备底层功能的实现依托于Cordova插件，其本质是Cordova插件的TypeScript包装。Ionic Native 默认为插件实现了Promise或Observable回调，为所有插件和本地事件变化监听提供了通用的接口。它会给所有的插件方法提供一个完整的类型说明，帮助使用者来获取库的类型提示，方便使用。</p>
<h2 id="插件使用">插件使用</h2>
<p>获取插件：https://ionicframework.com/docs/native/</p>
<h4 id="1-为项目集成cordova">1. 为项目集成Cordova：</h4>
<pre><code>    ```
    ionic integrations enable cordova --add  
    ```
</code></pre>
<h4 id="2-安装cordova插件">2. 安装Cordova插件：</h4>
<pre><code>    ```
    // 安装已经发布到线上的插件只需要输入发布插件的名称
    ionic cordova plugin add &lt;cordova-plugin-name&gt;
    // ionic cordova plugin add cordova-plugin-x-toast

    //安装公司内部自定义的插件（本地插件，未发布）
    ionic cordova plugin add &lt;cordova-plugin-path&gt;
    //ionic cordova plugin add /Users/wangle/Downloads/cordova-ble
    ```
</code></pre>
<h4 id="3-安装cordova插件对应的ionicnative包">3. 安装Cordova插件对应的IonicNative包：</h4>
<pre><code>    ```
    npm install &lt;ionic-native-name&gt;
    // npm install @ionic-native/toast
    ```
</code></pre>
<h4 id="4-实例化插件并使用">4. 实例化插件，并使用</h4>
<pre><code>    ```
    // 首先需要到AppModule中的@NgModule注解中将要注入的插件对象的类配置到providers中。
    import { Toast } from '@ionic-native/toast/ngx';

    constructor(private toast: Toast) { }

    ...

    this.toast.show(`I'm a toast`, '5000', 'center').subscribe(
    toast =&gt; {
        console.log(toast);
    }
    );
    ```
</code></pre>
<h4 id="5-查看当前项目中已安装的所有插件">5. 查看当前项目中已安装的所有插件</h4>
<pre><code>```
    ionic cordova plugin ls
```
![](https://merpyzf.github.io/post-images/1584547318777.png)
</code></pre>
<h4 id="6-移除插件">6. 移除插件</h4>
<pre><code>```
    ionic cordova plugin rm &lt;插件id&gt;
```
</code></pre>
<h2 id="调用插件方法时需要的地方">调用插件方法时需要的地方：</h2>
<ol>
<li>
<p>Promise: 插件方法只返回一个结果值</p>
</li>
<li>
<p>Observable： 插件方法将返回多个结果值<br>
比如当我们调用扫描附近蓝牙的插件方法时，由于扫描的结果不是一次给出的，需要在扫描到一个可用蓝牙设备时才可以将结果返回。<strong>我们在使用这类返回结果的插件方法时应当在完成所需功能后及时取消订阅或者调用插件提供的方法停止结果的返回。</strong></p>
</li>
</ol>
<h2 id="关于cordova插件需要明确的几个点">关于Cordova插件需要明确的几个点：</h2>
<ol>
<li>Cordova插件能够在任何基于Cordova 的工程中使用，和使用的什么前端框架（如Ionic）无关。</li>
<li>IonicNative只是为了方便我们使用Cordova插件，它不是必须的。即使安装了插件对应的IonicNatvie包也还是需要使用去添加插件。<code>cordova plugin add &lt;cordova-plugin-name&gt;</code></li>
</ol>
<h1 id="二-新增功能与组件库的使用">二、新增功能与组件库的使用</h1>
<h2 id="新增功能时的常用命令">新增功能时的常用命令</h2>
<ol>
<li>
<p>创建页面: <code>ionic g page &lt;YourPageName&gt;</code></p>
</li>
<li>
<p>创建组件: <code>ionic g component &lt;YourComponentName&gt;</code></p>
</li>
<li>
<p>创建服务: <code>ionic g provider &lt;YourProviderName&gt;</code></p>
</li>
<li>
<p>创建指令: <code>ionic g directive &lt;YourDirectiveName&gt;</code></p>
</li>
<li>
<p>创建过滤器 <code>ionic g pipe &lt;YourPipeName&gt;</code></p>
</li>
<li>
<p>创建路由守卫 <code>ionic g guard guard &lt;YourGuardName&gt;</code></p>
</li>
</ol>
<h2 id="组件库的使用">组件库的使用</h2>
<pre><code>访问Ionic提供的官方文档去查阅组件的使用方法：

https://ionicframework.com/docs/components
</code></pre>
<h1 id="三-浏览器与移动端设备的调试方法">三、浏览器与移动端设备的调试方法</h1>
<h2 id="当项目运行在浏览器时的调试方法">当项目运行在浏览器时的调试方法</h2>
<h3 id="1-通过打印日志的方式调试">1. 通过打印日志的方式调试</h3>
<pre><code>```
console.log('message') // 提示信息
console.log(var) // 变量值
```
</code></pre>
<p>这将会在浏览器的开发者工具的Console面板中输出代码相关的值和提示信息，你可以通过输出的信息来检查代码运行的逻辑是否正确。</p>
<p>以Chrome为例，通过按F12(Windows)或Option+Command+I(MacOS)进入开发者模式，点击Console面板即可查看程序输出的日志信息。<br>
<img src="https://merpyzf.github.io/post-images/1584426453622.png" alt="" loading="lazy"></p>
<h3 id="2-通过设置断点调试">2. 通过设置断点调试</h3>
<p>通过设置断点来对代码进行单步调试能够快速的定位Bug产生的源头和认清代码的执行流程（如果开发的环境支持单步调试，应首选单步调试作为查错的手段）。</p>
<p>以Chrome浏览器为例介绍单步调试的步骤：</p>
<ol>
<li>打开开发者工具中的Sources面板<br>
<img src="https://merpyzf.github.io/post-images/1584427960714.png" alt="" loading="lazy"></li>
<li>设置断点<br>
<img src="https://merpyzf.github.io/post-images/1584428042572.png" alt="" loading="lazy"></li>
<li>单步调试<br>
设置好断点后，需要操作对应的按钮进行调试，按钮如下：<br>
<img src="https://merpyzf.github.io/post-images/1584429658045.png" alt="" loading="lazy"><br>
从左到右分别是：
<ol>
<li>Pause/Resume script execution：暂停或恢复代码的执行（代码将执行到下一个断点处停止）。</li>
<li>Step over next function call：执行到下一处的函数调用（执行当前断点所在的行，跳到下一行后暂停，不会进入函数内部）。</li>
<li>Step into next function call：进入当前函数，并在函数内部的第一行代码处暂停。</li>
<li>Step out of current function：跳出当前执行的函数。</li>
<li>Deactive/Active all breakpoints：关闭/开启所有断点。</li>
<li>Pause on exceptions：代码自动暂停到发生异常的地方。</li>
</ol>
</li>
</ol>
<p>详细教程：<a href="https://developers.google.com/web/tools/chrome-devtools/javascript?hl=zh-cn">在 Chrome DevTools 中调试 JavaScript </a></p>
<h2 id="当项目运行在移动端设备时的调试方法">当项目运行在移动端设备时的调试方法</h2>
<p>虽然浏览器的设备模拟功能很强大，但是我们在Chrome中模拟的移动端的网页最终在移动端环境下运行的时候可能会遇到一些样式错乱的问题，或者当我们需要对插件的功能进行开发的时候就需要将程序运行到真机上进行调试。</p>
<h3 id="真机调试前的环境准备">真机调试前的环境准备</h3>
<h4 id="1-为电脑安装adb工具">1. 为电脑安装ADB工具</h4>
<p>可以直接通过<a href="https://developer.android.com/studio?hl=zh-cn">安装AndroidStuido</a>来获取ADB命令，同时IDE中会提供一个查看Logcat日志的图形界面。或者(单独安装ADB工具包）[https://juejin.im/post/5baaf0f95188255c5442af1e]</p>
<h4 id="2-在android设备的开发者选项中开启调试并将设备通过数据线连接到电脑">2. 在Android设备的开发者选项中开启调试，并将设备通过数据线连接到电脑</h4>
<h4 id="3-通过-adb-install-xxxxapk命令将打包生成的apk安装到设备运行">3. 通过 adb install &lt;/xx/xx.apk&gt;命令将打包生成的apk安装到设备运行</h4>
<p>如果平台代码中有通过 productFlavors 设置多渠道打包，那么最后执行打包命令将会生成多个apk，此时就需要我们手动执行adb提供的install命令来进行软件的安装。</p>
<h3 id="1-根据logcat输出的日志信息调试">1. 根据Logcat输出的日志信息调试</h3>
<ol>
<li>通过 AndtoidStuido提供Logcat窗口查看程序输出的日志信息：<br>
<img src="https://merpyzf.github.io/post-images/1584452445648.png" alt="" loading="lazy"></li>
<li>通过ADB命令 adb logcat &gt; filename 将日志信息输出到文件查看<br>
<img src="https://merpyzf.github.io/post-images/1584452777188.png" alt="" loading="lazy"><br>
通过日志信息中包含的关键字检索内容：<br>
<img src="https://merpyzf.github.io/post-images/1584453361505.png" alt="" loading="lazy"></li>
</ol>
<h3 id="2-通过chrome的远程调试功能">2. 通过Chrome的远程调试功能</h3>
<p><strong>使用Chrome远程调试模式的前提是需要通过添加--debug参数来将程序运行到真机，避免TypeScript代码被编译成JavaScript。通过如下命令：</strong></p>
<pre><code>// -l （live-reload实时重载）
ionic cordova run &lt;ios or android&gt; --device -l --debug
</code></pre>
<ol>
<li>在电脑端的Chrome的地址栏输入chrome://inspect。进入后确认Discover USB devices 已经勾选了：<br>
<img src="https://merpyzf.github.io/post-images/1584453972586.png" alt="" loading="lazy"></li>
<li>在你的设备上将会跳出一个警告，提示你是否要允许在电脑端进行 USB 调试。选择 OK。此时在chrome://inspect 页面上将会显示所有已经连接的设备：<br>
<img src="https://merpyzf.github.io/post-images/1584454009529.png" alt="" loading="lazy"></li>
<li>点击浏览器选项卡下面的 inspect开始调试：<br>
<img src="https://merpyzf.github.io/post-images/1584455106723.png" alt="" loading="lazy"></li>
</ol>
<p><strong>注意： 如果在运行程序的时候没有添加--debug参数，最后看到的项目结构如下，TypeScript已被编译成JavaScript，丧失了一致性，因此无法进行后续的调试工作：</strong><br>
<img src="https://merpyzf.github.io/post-images/1584455637307.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基于Cordova创建Ionic插件]]></title>
        <id>https://merpyzf.github.io/post/ji-yu-cordova-chuang-jian-ionic-cha-jian/</id>
        <link href="https://merpyzf.github.io/post/ji-yu-cordova-chuang-jian-ionic-cha-jian/">
        </link>
        <updated>2020-03-13T10:16:43.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>克隆Github中的Ionic-Native的项目到本地，后面命令的执行和插件文件模版的生成需要依赖此环境。</p>
</li>
<li>
<p>进入ionic-native的根目录</p>
</li>
<li>
<p>创建插件包</p>
<pre><code>// 调用此命令，并将`PluginName`替换为希望添加的插件名称
// 第一个字母一定要大写，使用大驼峰命名
gulp plugin:create -n PluginName
</code></pre>
<p>执行完以上命令将会在src/@ionic-native/plugins目录下创建一个名称为PluginName的插件目录，里面有一个index.ts文件，后面Ionic插件的编写就是需要在这个文件中进行的。</p>
</li>
<li>
<p>编写index.ts</p>
<pre><code>@Plugin({
pluginName: 'ZijinUtilPlugin',
plugin: 'cordova-plugin-x-zijinutil', // npm package name, example: cordova-plugin-camera
pluginRef: 'cordova.plugins.ZijinUtil', // the variable reference to call the plugin, example: navigator.geolocation
platforms: ['Android'] // Array of platforms supported, example: ['Android', 'iOS']
})
@Injectable()
export class ZijinUtilPlugin extends IonicNativePlugin {
}
</code></pre>
</li>
</ol>
<p>这里需要重点指出的是 @Plugin装饰器中参数的添加：</p>
<ol>
<li>
<p>pluginRef：指的是底层Cordova插件的应用方式，这个值和cordova插件中的plugin.xml下的clobbers节点值相同。</p>
</li>
<li>
<p>plugin：值的是npm包的名称</p>
</li>
<li>
<p>通过调用 npm run build <pluginName> 来完成对插件的编辑，最后编译的结果会生成到ionic-native/dist/@ionic-native/plugins目录。如果是使用的是MacOS系统进行的编译还有可能会出现如下的错误：<code>Error: ENOENT: no such file or directory, open '/Users/wangke/Workspace/CompanyProjects/ionic-native/dist/@ionic-native/plugins/.DS_Store/index.js'</code>。通过执行 find . -name '.DS_Store' -type f -delete 命令后即可解决上述问题。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Cordova插件开发指南]]></title>
        <id>https://merpyzf.github.io/post/cordova-cha-jian-kai-fa-zhi-nan/</id>
        <link href="https://merpyzf.github.io/post/cordova-cha-jian-kai-fa-zhi-nan/">
        </link>
        <updated>2020-03-11T01:53:20.000Z</updated>
        <content type="html"><![CDATA[<p>下文为对<a href="https://cordova.apache.org/docs/en/9.x/guide/hybrid/plugins">Cordova官网插件开发</a>的翻译。</p>
<h3 id="简介">简介</h3>
<p>插件是注入的代码包，可让Cordova Web视图在该视图中渲染应用程序并与其运行所在的本机平台进行通信。插件提供对通常基于Web的应用程序不可用的设备和平台功能的访问。 Cordova API的所有主要功能均作为插件实现，还有许多其他功能可启用诸如条形码扫描仪，NFC通信或定制日历界面等功能。</p>
<p>插件包含一个JavaScript接口(插件www目录下的js文件)，以及每个受支持平台的相应本机代码库。本质上，这将各种本机代码实现隐藏在通用JavaScript接口的后面，您可以将其用作模型来构建更复杂的功能。本节讨论基本的插件结构和面向外部的JavaScript接口。</p>
<figure data-type="image" tabindex="1"><img src="https://merpyzf.github.io/post-images/1583897837999.png" alt=" Cordova 应用程序体系结构" loading="lazy"></figure>
<h3 id="向项目中添加插件">向项目中添加插件</h3>
<p>应用程序开发人员使用CLI的plugin add命令将插件添加到项目中。该命令的参数是包含插件代码的git存储库的URL(也可以是插件所在的本地路径)。此示例实现了Cordova的设备API：</p>
<pre><code>cordova plugin add https://git-wip-us.apache.org/repos/asf/cordova-plugin-device.git
</code></pre>
<p>存储在git上的插件存储库必须具有顶级的plugin.xml清单文件。有许多方法可以配置此文件，有关详细信息，请参见<a href="https://cordova.apache.org/docs/en/9.x/plugin_ref/spec.html">插件规范</a>。<br>
👇这个简短的Device插件版本提供了一个简单的示例展示：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;plugin xmlns=&quot;http://apache.org/cordova/ns/plugins/1.0&quot;
        id=&quot;cordova-plugin-device&quot; version=&quot;0.2.3&quot;&gt;
    &lt;name&gt;Device&lt;/name&gt;
    &lt;description&gt;Cordova Device Plugin&lt;/description&gt;
    &lt;license&gt;Apache 2.0&lt;/license&gt;
    &lt;keywords&gt;cordova,device&lt;/keywords&gt;
    &lt;js-module src=&quot;www/device.js&quot; name=&quot;device&quot;&gt;
        &lt;clobbers target=&quot;device&quot; /&gt;
    &lt;/js-module&gt;
    &lt;platform name=&quot;ios&quot;&gt;
        &lt;config-file target=&quot;config.xml&quot; parent=&quot;/*&quot;&gt;
            &lt;feature name=&quot;Device&quot;&gt;
                &lt;param name=&quot;ios-package&quot; value=&quot;CDVDevice&quot;/&gt;
            &lt;/feature&gt;
        &lt;/config-file&gt;
        &lt;header-file src=&quot;src/ios/CDVDevice.h&quot; /&gt;
        &lt;source-file src=&quot;src/ios/CDVDevice.m&quot; /&gt;
    &lt;/platform&gt;
&lt;/plugin&gt;
</code></pre>
<p>顶级插件标签的id属性使用相同的反向域格式来标识插件包添加到他们的应用程序所能识别的插件包，js-module标记指定通用JavaScript接口（即与native层通信的js）的路径。在这种情况下，platform标签为ios平台指定了一组对应的本机代码（细化到每一个源代码文件的源文件位置和导出到平台后要放置的位置，以及引用的第三方库）。config-file标记封装了功能标记，该feature标记注入到特定于平台的config.xml文件中，以使平台知道其他的代码库。header-file和source-file标签指定头文件和源码文件的路径。</p>
<h3 id="使用plugman验证插件">使用Plugman验证插件</h3>
<p>您可以使用plugman实用程序来检查插件是否针对每个平台正确安装。使用以下节点命令安装plugman：</p>
<pre><code>pm install -g plugman
</code></pre>
<p>然后运行以下命令来测试iOS依赖项是否正确加载：</p>
<pre><code>plugman install --platform ios --project /path/to/my/project/www --plugin /path/to/my/plugin
</code></pre>
<h3 id="javascript接口">JavaScript接口</h3>
<p>JavaScript接口提供了面向前端调用Native层功能的接口，使其成为插件中最重要的部分。您可以随意构建插件的JavaScript，但需要使用以下语法调用cordova.exec与Native层进行通信：</p>
<pre><code>cordova.exec(function(winParam) {},
             function(error) {},
             &quot;service&quot;,
             &quot;action&quot;,
             [&quot;firstArgument&quot;, &quot;secondArgument&quot;, 42, false]);
</code></pre>
<p>👇介绍每个参数的工作原理：</p>
<ul>
<li>function(winParam) {}：成功的回调函数。假设您的exec调用成功完成，此函数将被执行并携带Native层传递的关于成功信息的参数。</li>
<li>function(error) {}: 失败的回调函数。如果操作未成功完成，此函数将被执行并携带Native层传递的关于失败信息的参数。</li>
<li>&quot;service&quot;：在Native端调用的服务名称。这对应于Native层的类.</li>
<li>&quot;action&quot;: 在Native端调用的操作名称。这通常对应于Native层类中用于实现插件功能的方法名称。</li>
<li>[/* arguments */]: 一个Json数组对象，作为参数传递到Native层的方法中。</li>
</ul>
<p>JavaScript插件调用示例：</p>
<p>👇示例显示了一种实现调用插件JavaScript接口的方法：</p>
<pre><code>window.echo = function(str, callback) {
    cordova.exec(callback, function(err) {
        callback('Nothing to echo.');
    }, &quot;Echo&quot;, &quot;echo&quot;, [str]);
};
</code></pre>
<p>在此示例中，插件将自身作为echo函数附加到window对象上，该插件将被用户按照以下方式调用：</p>
<pre><code>window.echo(&quot;echome&quot;, function(echoValue) {
    alert(echoValue == &quot;echome&quot;); // should alert true.
});
</code></pre>
<h3 id="native层实现">Native层实现</h3>
<p>为插件定义JavaScript接口后，至少需要使用一种本机实现对其进行补充。下面将介绍<br>
Android层的实现（因为本人只熟悉Android平台的开发）。</p>
<h4 id="android插件开发说明">Android插件开发说明</h4>
<p>Android插件基于 Cordova-Android。它的作用是构建一座从WebView通向Native的桥梁。Android插件的Native部分至少要包含一个Java类，该类继承自CordovaPlugin类并重写父类的execute方法。</p>
<h5 id="插件类映射">插件类映射</h5>
<p>插件的JavaScript接口使用cordova.exec方法，如下所示：</p>
<pre><code>exec(&lt;successFunction&gt;, &lt;failFunction&gt;, &lt;service&gt;, &lt;action&gt;, [&lt;args&gt;]);
</code></pre>
<p>这封装了从WebView到Android本机端的请求，完成了对service类上的action方法的调用，并向action方法中传递了args数组参数。</p>
<p>无论您是以Java文件还是以自己的jar文件发布插件，必须在您的Cordova-Android应用程序的res / xml / config.xml文件中指定该插件。有关如何使用plugin.xml文件注入此功能元素的更多信息，请参见应用程序插件：</p>
<pre><code> &lt;platform name=&quot;android&quot;&gt;
        &lt;config-file parent=&quot;/*&quot; target=&quot;res/xml/config.xml&quot;&gt;
            &lt;feature name=&quot;&lt;service_name&gt;&quot;&gt;
                &lt;param name=&quot;android-package&quot; value=&quot;&lt;full_name_including_namespace&gt;&quot; /&gt;
            &lt;/feature&gt;
        &lt;/config-file&gt;
        ...
&lt;/platform&gt;
</code></pre>
<p>__service_name与JavaScript exec调用中使用的名称相匹配。value的值是继承了CordovaPlugin类的全路径。__如果配置有误，该插件虽然可能会通过编译，但Cordova仍无法完成插件调用。</p>
<h5 id="插件初始化和生命周期">插件初始化和生命周期</h5>
<p>在每个WebView的生存期内，都会创建一个插件对象的实例。但是默认情况下，插件不会跟随WebView一同创建，而是直到JavaScript调用首次引用插件时，才会实例化插件。除非在config.xml中将具有onload name属性的<param>设置为“ true”。例如，</p>
<pre><code>&lt;!-- 设置跟随WebView初始化插件 --&gt;
&lt;feature name=&quot;Echo&quot;&gt;
    &lt;param name=&quot;android-package&quot; value=&quot;&lt;full_name_including_namespace&gt;&quot; /&gt;
    &lt;param name=&quot;onload&quot; value=&quot;true&quot; /&gt;
&lt;/feature&gt;
</code></pre>
<p>插件在启动时将会去回调initialize方法，可以在该方法内部做一些初始化工作。</p>
<pre><code>@Override
public void initialize(CordovaInterface cordova, CordovaWebView webView) {
    super.initialize(cordova, webView);
    // your init code here
}
</code></pre>
<p>插件还可以访问Android生命周期事件，并且可以通过实现父类CordovaPlugin提供的方法（onResume，onDestroy等）来处理它们。具有长时间运行的请求、后台活动(如媒体播放、侦听器或内部状态)的插件应该实现 onReset ()方法。 它在 WebView 导航到新页面或刷新时执行，这会重新加载 JavaScript。</p>
<h5 id="编写一个android插件">编写一个Android插件</h5>
<p>一个JavaScript调用将向Native层发出一个插件调用请求，并且相应的Java插件已正确映射到config.xml文件中，但是最终的Android Java Plugin类是什么样的？使用JavaScript的exec函数调用的插件回将所有的内容传递到插件类的execute 方法中。大多数执行实现如下所示：</p>
<pre><code>@Override
public boolean execute(String action, JSONArray args, CallbackContext callbackContext) throws JSONException {
    if (&quot;beep&quot;.equals(action)) {
        this.beep(args.getLong(0));
        callbackContext.success();
        return true;
    }
    return false;  // Returning false results in a &quot;MethodNotFound&quot; error.
}
</code></pre>
<p>可以通过action参数来分配本次调用需要执行的方法。<strong>当插件类的execute方法执行后如果最后返回的是false，则会在JS层抛出 &quot;MethodNotFound&quot; 的错误。</strong></p>
<h5 id="线程">线程</h5>
<p><strong>插件的JavaScript不在WebView界面的主线程中运行；相反，它与execute方法一样在WebCore线程上运行</strong>。如果需要与用户界面进行交互，则应使用Activity的runOnUiThread方法，如下所示：</p>
<pre><code>@Override
public boolean execute(String action, JSONArray args, final CallbackContext callbackContext) throws JSONException {
    if (&quot;beep&quot;.equals(action)) {
        final long duration = args.getLong(0);
        cordova.getActivity().runOnUiThread(new Runnable() {
            public void run() {
                Toast.make(context, &quot;hi&quot;, Toast.LENGTH_SHORT).show();
                callbackContext.success(); // Thread-safe.
            }
        });
        return true;
    }
    return false;
}
</code></pre>
<p>如果不需要在UI线程上运行，但是也不想阻塞WebCore线程，则应通过cordova.getThreadPool（）获得的Cordova的ExecutorService（Java中对线程池定义的一个接口）执行代码，如下所示：</p>
<pre><code>@Override
public boolean execute(String action, JSONArray args, final CallbackContext callbackContext) throws JSONException {
    if (&quot;beep&quot;.equals(action)) {
        final long duration = args.getLong(0);
        cordova.getThreadPool().execute(new Runnable() {
            public void run() {
                ...
                callbackContext.success(); // Thread-safe.
            }
        });
        return true;
    }
    return false;
}
</code></pre>
<h5 id="添加依赖库">添加依赖库</h5>
<p>如果您的Android插件具有额外的依赖，则必须通过以下两种方式之一在plugin.xml中列出它们。</p>
<h6 id="方法1">方法1:</h6>
<p>使用 framework标记，<strong>以这种方式指定库允许通过Gradle的依赖管理逻辑对其进行解析。这允许多个插件使用通用库（例如gson，android-support-v4和google-play-services）而不会发生冲突。</strong><br>
下面为通过framework标记引入依赖库的示例：</p>
<pre><code>&lt;!-- Depend on latest version of GCM from play services --&gt;
&lt;framework src=&quot;com.google.android.gms:play-services-gcm:+&quot; /&gt;
&lt;!-- Depend on v21 of appcompat-v7 support library --&gt;
&lt;framework src=&quot;com.android.support:appcompat-v7:21+&quot; /&gt;
&lt;!-- Depend on library project included in plugin --&gt;
&lt;framework src=&quot;relative/path/FeedbackLib&quot; custom=&quot;true&quot; /&gt;
</code></pre>
<p>Framework也可以用于将自定义.gradle文件包含在插件主项目的build.gradle文件中:</p>
<figure data-type="image" tabindex="2"><img src="https://merpyzf.github.io/post-images/1583899538203.png" alt="" loading="lazy"></figure>
<h6 id="方法2">方法2:</h6>
<p>使用lib-file标记指定jar文件的位置,仅当您确定没有其他插件引用该库时才应使用此方法。（如果有多个插件通过lib-file标记引用了相同的jar，将会导致冲突发生）。否则，如果另一个插件添加相同的库，则可能会给插件的用户造成构建错误。</p>
<h5 id="android整合">Android整合</h5>
<p>Android具有Intent系统，该系统允许进程相互通信。插件可以访问CordovaInterface对象，该对象可以访问运行该应用程序的Android 。 CordovaInterface允许插件允许启动一个可以返回结果的Activity。从Cordova 2.0开始，插件不再可以直接访问Context，并且已弃用旧版ctx成员。所有ctx方法都存在于Context上，因此通过getContext（）和getActivity（）都可以返回所需的对象。</p>
<h5 id="android静态权限">Android静态权限</h5>
<p>对于在那些在安装时授权而非在运行时授权的权限，需要将这些在应用程序中使用层的权限添加到Android清单中。这可以通过使用config.xml将这些权限注入到AndroidManifest.xml文件来完成。下面为申请权限的示例：</p>
<pre><code>    &lt;config-file target=&quot;AndroidManifest.xml&quot; parent=&quot;/manifest&quot;&gt;
            &lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot;/&gt;
            &lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot;/&gt;
            &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;
        &lt;/config-file&gt;
</code></pre>
<h5 id="android运行时权限">Android运行时权限</h5>
<p>Android 6.0“棉花糖”引入了新的权限模型，用户可以根据需要打开和关闭权限。这意味着应用程序必须处理这些权限更改，以确保时效性，这是Cordova-Android 5.0.0版本的重点。可以在<a href="http://developer.android.com/guide/topics/security/permissions.html#perm-groups">此处</a>的Android Developer文档中找到需要在运行时处理的权限。</p>
<p>就插件而言，可以通过调用权限方法来请求权限。方法签名如下：</p>
<pre><code>cordova.requestPermission(CordovaPlugin plugin, int requestCode, String permission);
</code></pre>
<p>为了减少冗长，通常的做法是将其分配给局部静态变量：</p>
<pre><code>public static final String READ = Manifest.permission.READ_CONTACTS;
</code></pre>
<p>按照以下方式定义requestCode也是标准做法：</p>
<pre><code>public static final int SEARCH_REQ_CODE = 0;
</code></pre>
<p>然后，在exec方法中，应检查权限：</p>
<pre><code>if(cordova.hasPermission(READ))
{
    search(executeArgs);
}
else
{
    getReadPermission(SEARCH_REQ_CODE);
}
</code></pre>
<p>在getReadPermission方法中通过调用requestPermission来申请权限：</p>
<pre><code>protected void getReadPermission(int requestCode)
{
    cordova.requestPermission(this, requestCode, READ);
}
</code></pre>
<p>执行上述语句后将会弹出权限授权弹窗，之后交由用户处理。当用户处理完成后，插件将会回调onRequestPermissionResult来返回对权限的授权结果。每个插件都应该重写此方法。下面是一个示例：</p>
<pre><code>public void onRequestPermissionResult(int requestCode, String[] permissions,
                                         int[] grantResults) throws JSONException
{
    for(int r:grantResults)
    {
        if(r == PackageManager.PERMISSION_DENIED)
        {
            this.callbackContext.sendPluginResult(new PluginResult(PluginResult.Status.ERROR, PERMISSION_DENIED_ERROR));
            return;
        }
    }
    switch(requestCode)
    {
        case SEARCH_REQ_CODE:
            search(executeArgs);
            break;
        case SAVE_REQ_CODE:
            save(executeArgs);
            break;
        case REMOVE_REQ_CODE:
            remove(executeArgs);
            break;
    }
}
</code></pre>
<p>除了为单个权限请求权限外，还可以通过定义权限数组来请求整个组的权限，就像使用Geolocation插件那样：</p>
<pre><code>String [] permissions = { Manifest.permission.ACCESS_COARSE_LOCATION, Manifest.permission.ACCESS_FINE_LOCATION };
</code></pre>
<p>然后在对组的权限进行申请时，需要进行如下操作：</p>
<pre><code>cordova.requestPermissions(this, 0, permissions);
</code></pre>
<h5 id="启动其他活动">启动其他活动</h5>
<p>待添加</p>
<h3 id="发布插件">发布插件</h3>
<p>您可以将插件发布到任何基于npmjs的注册表，但是推荐的插件是npm注册表。其他开发人员可以使用Plugman或Cordova CLI自动安装您的插件。</p>
<p>要将插件发布到npm，您需要执行以下步骤：</p>
<ol>
<li>安装plugman命令行工具：<pre><code>$ npm install -g plugman
</code></pre>
</li>
<li>为插件创建一个package.json文件<pre><code>$ plugman createpackagejson /path/to/your/plugin
</code></pre>
</li>
<li>发布它：<pre><code>$ npm adduser # that is if you don't have an account yet
 $ npm publish /path/to/your/plugin
</code></pre>
</li>
</ol>
<!-- ### 指定Cordova依赖项
Cordova 6.1.0添加了对指定插件的Cordova相关依赖项的支持，作为插件的package.json文件的一部分。插件可能会列出多个发行版的依赖关系，以在Cordova CLI选择要从npm获取的插件版本时向其提供指导。CLI将选择与本地项目的已安装平台和插件以及本地Cordova CLI版本兼容的最新版本的插件。如果没有兼容的插件版本，则CLI将警告用户有关失败的要求，并退回获取最新版本的旧行为。 -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于CallbackContext中的sendPluginResult方法的作用]]></title>
        <id>https://merpyzf.github.io/post/guan-yu-callbackcontext-zhong-de-sendpluginresult-fang-fa-de-zuo-yong/</id>
        <link href="https://merpyzf.github.io/post/guan-yu-callbackcontext-zhong-de-sendpluginresult-fang-fa-de-zuo-yong/">
        </link>
        <updated>2020-03-09T08:36:12.000Z</updated>
        <content type="html"><![CDATA[<p>一般情况下我们编写的插件方法只需要返回一次结果值，比如对蓝牙可用性的判断：</p>
<pre><code>  private void bluetoothEnable() {
        if (bleAdapter.isEnabled()) {
            callbackContext.success(&quot;蓝牙可用&quot;);
        } else {
            callbackContext.error(&quot;蓝牙不可用&quot;);
        }
    }
</code></pre>
<p>但是有一种情况需要注意，比如在做一个搜索附近蓝牙的插件，由于结果不是一次性给出的，可能每隔一会儿才能搜索到一个可用的蓝牙设备，需要把每一次搜索到的蓝牙设备信息传递给JS层，如果通过callbackContext.success()方法进行重复调用则会引发错误且无法完成结果的传递，通过查看源码可以发现：</p>
<pre><code>  public void sendPluginResult(PluginResult pluginResult) {
        synchronized (this) {
            if (finished) {
                LOG.w(LOG_TAG, &quot;Attempted to send a second callback for ID: &quot; + callbackId + &quot;\nResult was: &quot; + pluginResult.getMessage());
                return;
            } else {
                finished = !pluginResult.getKeepCallback();
            }
        }
        webView.sendPluginResult(pluginResult, callbackId);
    }
</code></pre>
<p>当我们直接调用success或error方法返回结果给JS层时，最终调用的方法为sendPluginResult，pluginResult.getKeepCallback()方法获取的是keepCallback的值，它的默认值为false，因此通过以上方法只能实现一次结果的返回，当第二次调用的时keepCallback的值就已经被设置为true，继而会在控制台打印如下警告：Attempted to send a second callback for ID...并直接return。</p>
<p>因此如果我们想要向JS层多次返回结果时就需要将keepCallback的值手动设置为true，通过以下方法可完成结果的多次返回操作：</p>
<pre><code>PluginResult pluginResult = new PluginResult(PluginResult.Status.OK,&quot;message&quot;);
pluginResult.setKeepCallback(true);
callbackContext.sendPluginResult(pluginResult);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[初识 Ionic Framework]]></title>
        <id>https://merpyzf.github.io/post/zhe-shi-yi-pian-ce-shi-de-wen-zhang/</id>
        <link href="https://merpyzf.github.io/post/zhe-shi-yi-pian-ce-shi-de-wen-zhang/">
        </link>
        <updated>2020-03-05T10:11:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="ionic框架">Ionic框架</h3>
<h4 id="是什么">是什么？</h4>
<p>Ionic Framework是一个开源UI工具包，通过使用Web技术（HTML，CSS和JavaScript）构建高性能，高质量的移动和桌面应用程序。</p>
<p>Ionic Framework专注于前端用户体验或应用程序的UI交互（控件，交互，手势，动画）。并且可以与Angular等其他库或框架做到很好地集成，或者可以在没有前端框架的情况下独立使用。</p>
<h4 id="目标">目标</h4>
<ul>
<li>
<p><strong>跨平台</strong>：构建并部署可在多个平台（例如本机iOS，Android，桌面和网络）上运行的应用程序，作为渐进式Web应用程序-只需一个代码库即可。编写一次，即可在任何地方运行。</p>
</li>
<li>
<p><strong>基于Web标准</strong>：Ionic Framework使用可靠的标准化Web技术（HTML，CSS和JavaScript）构建，并使用自定义元素和Shadow DOM等现代Web API。因此，Ionic组件具有稳定的API，并且不受单个平台供应商的追捧。</p>
</li>
<li>
<p><strong>精美的设计</strong>：干净，简单且实用。 Ionic Framework旨在在所有平台上开箱即用地精美显示。从预先设计的组件，版式，交互式范例和华丽的（但仍可扩展的）基本主题开始。</p>
</li>
<li>
<p><strong>简单</strong>：Ionic Framework的构建考虑到了简单性，因此创建Ionic应用程序非常有趣，易于学习，并且几乎所有具有Web开发技能的人都可以使用。</p>
</li>
</ul>
<h4 id="核心概念">核心概念</h4>
<ul>
<li>
<p><strong>UI组件</strong>：<strong>Ionic Framework是UI组件的库</strong>，UI组件是可重用的元素，它们充当应用程序的构建块。尽管这些组件是预先构建的，但它们的设计是完全可定制的，因此应用程序可以将每个组件制作为自己的组件，允许每个应用都有自己的外观。更具体地说，可以轻松地将Ionic组件设置为主题，以在整个应用程序中全局更改外观。</p>
</li>
<li>
<p><strong>自适应样式</strong>：自适应样式是Ionic Framework的内置功能，它允许应用程序开发人员将相同的代码库用于多个平台。每个Ionic组件都会根据其运行该应用程序的平台调整其外观。例如，Apple设备（例如iPhone和iPad）使用Apple自己的iOS设计语言。例如，Apple设备（例如iPhone和iPad）使用Apple自己的iOS设计语言。同样，Android设备使用Google的称为Material Design的设计语言。通过在平台之间进行细微的设计更改，可以为用户提供熟悉的应用程序体验。从Apple的App Store下载的Ionic应用程序将获得iOS主题，而从Android的Play Store下载的Ionic应用程序将获得Material Design主题。对于从浏览器中视为渐进式Web应用程序（PWA）的应用程序，Ionic将默认使用Material Design主题。此外，决定在某些情况下使用哪个平台是完全可配置的。有关自适应样式的更多信息，请参见主题。</p>
</li>
<li>
<p><strong>导航</strong>：传统的Web应用程序使用线性历史记录，这意味着用户可以向前导航到页面，并且可以单击“后退”按钮来向后导航。一个示例是在Wikipedia上单击，用户在浏览器的线性历史记录堆栈上来回移动。相反，移动应用程序通常利用并行的“非线性”导航。例如，选项卡式界面可以为每个选项卡具有单独的导航堆栈，以确保用户在导航和在选项卡之间切换时不会丢失自己的位置。Ionic应用程序采用了这种移动导航方法，不仅支持嵌套的并行导航历史记录，而且还保留了Web开发人员熟悉的浏览器式导航概念。对于使用Angular和@ ionic / angular构建的应用程序，我们建议为每个新的Ionic 4 Angular应用程序使用开箱即用的Angular Router。</p>
</li>
<li>
<p><strong>本机访问</strong>：使用Web技术构建的应用程序（例如Ionic应用程序！）的一个惊人功能是，它几乎可以在任何平台上运行：台式计算机，电话，平板电脑，汽车，冰箱等！Ionic应用程序的相同代码库可以在许多平台上工作，因为它基于Web标准和在这些平台之间共享的通用API。Ionic的最常见用例之一是构建可从App Store和Play Store下载的应用程序。iOS和Android软件开发套件（SDK）均提供可呈现任何Ionic应用程序的Web视图，同时仍允许完整的Native SDK访问。通常使用诸如Capacitor和Cordova之类的项目为Ionic应用程序提供对Native SDK的访问权限。这意味着开发人员可以使用通用的Web开发工具快速构建应用程序，并且仍然可以访问设备的加速计，摄像头，GPS等本机功能。</p>
</li>
<li>
<p><strong>主题</strong>：Ionic Framework的核心是使用CSS构建的，它使我们能够利用CSS属性（变量）提供的灵活性。这使得在遵循Web标准的同时设计美观的应用程序变得异常容易。我们提供了一组颜色，以便开发人员可以有一些很棒的默认设置，但是我们建议您覆盖它们以创建与品牌，公司或所需调色板匹配的设计。从应用程序的背景颜色到文本颜色的所有内容都是完全可定制的。有关应用程序主题的更多信息，请参见主题。</p>
</li>
</ul>
]]></content>
    </entry>
</feed>